```c
#include "reg51.h"
#include "intrins.h"

sfr WKTCL = 0xAA;
sfr WKTCH = 0xAB;
sbit LED1 = P3^1;     
sbit LED2 = P3^0;

void delay_ms(unsigned int ms){
    unsigned int i, j;
    for(i = 0; i < ms; i++)
        for(j = 0; j < 1100; j++);
}

void main(void)
{
    // 先灭
    LED1 = 1;
    LED2 = 1;

    // 使能 WKT，设置较大间隔
    WKTCL = 0xFF;     // ≈124ms/次
    WKTCH = 0x80;     // 最高位1=使能

    while(1){
        // 醒来后可见地停留一会儿再睡
        LED1 = !LED1;           // 翻转（Active-Low）
        LED2 = !LED2;
        delay_ms(1500);          // 给人眼看的时间

        PCON = 0x02;            // 进 STOP
        _nop_(); _nop_();       // 稍作保护延时
        // 到这儿 MCU 睡了，等 WKT 到时再自动唤醒继续循环
    }
}
```


# 1) 到底啥是“省电/掉电(STOP)”？

把 MCU 当成一个人：

* 清醒＝CPU跑代码、主时钟在转、外设都开，耗电大；
* 睡觉(STOP)＝把绝大多数电路都关掉，只留一个小闹钟（**唤醒定时器 WKT**）在滴答滴答计时，等时间到再把人叫醒。

这样做的意义：**大部分时间不干活→超省电**；只在需要时醒来干一下再睡。

---

# 2) 进入“睡觉”是怎么触发的？

```c
PCON = 0x02;   // 写这句就进 STOP
```

* `PCON` 是电源控制寄存器。
* 给它写 `0x02`（相当于把“掉电位”置 1），MCU 立刻进入 **STOP 模式**。
* 进 STOP 的那一刻，**CPU停了、主时钟停了**，但**端口电平保持不变**（锁存着你写过的 0/1）。

  * 这就是为什么你把 LED 置为“亮”再 STOP，它会**继续亮着**：因为口线保持之前的电平。

> 贴士：紧跟两条 `_nop_()` 只是加两个“空动作”，给硬件一个**稳定过渡的喘息**，避免边界时序问题（习惯性写法）。

---

# 3) 睡着后，谁还在工作？

**唤醒定时器 WKT**。它是个独立的小闹钟，用内部 32kHz 时钟在计时。

* 你用这两行把它开起来并设定间隔：

  ```c
  WKTCL = 0xFF;   // 计数值（低 8 位）
  WKTCH = 0x80;   // 最高位=1 表示“使能 WKT”
  ```
* 粗略公式：**唤醒间隔 ≈ (WKTCL/WKTCH组合值) × 488 微秒**
  （488 µs 来自 1/32768 Hz 的基准，一些芯片内部略有误差，所以只是“约等于”）
* 例子：`0xFF ≈ 255 × 488µs ≈ 124ms`，所以**大约 0.124 秒后它会把 MCU 叫醒**。

---

# 4) 被叫醒后，从哪儿继续跑？

从你写 `PCON = 0x02;` 的**下一条指令**继续运行（也就是 `_nop_()` 之后）。
因此一轮完整流程是：

```
[翻转LED] → [可见延时delay_ms(300)] → [PCON进睡] → (WKT计时约124ms)
→ [自动醒来] → [继续翻转LED] → …
```

**关键点：中间没有“中断服务函数”，也无需你写ISR**；WKT本身就能把 STOP 拉回到“正常运行”。

---

# 5) 省电的本质：把“清醒时间”变短

平均功耗 ≈ （清醒耗电 × 清醒时间 + 睡眠耗电 × 睡眠时间） / 总时间。
你想更省电，就**让清醒得更短、睡得更久**：

* **减少 `delay_ms()`** 的停留（醒来干完就睡）；
* **增大 WKT 计数** 或者**醒来 N 次才翻一次灯**，把“看得见的动作”稀释到更长周期；
* **醒来只做必要的工作**（读一下传感器、存一下值、发个包），立刻睡。

> 演示代码里之所以保留 `delay_ms(300)`，是为了让你**肉眼能看见灯在闪**。真实省电应用里，这段会很短甚至没有。

---

# 6) 睡觉时，IO 会不会乱？

不会。**端口会保持你进睡前的电平**：

* 你把 LED 口线写成 **0（低电平）**再睡——你的接法是**低电平点亮**——所以 STOP 期间它依然亮；
* 你把口线写成 **1**再睡——它就一直灭；
* 不建议把口线留“悬空/高阻”再睡（容易抖/耗电不可控）。**睡前把状态设好**是好习惯。

---

# 7) 为什么要 `WKTCH` 最高位=1？

因为这位是**使能位**：

* 0＝关闭 WKT（就算写了 WKTCL 也不会计时）；
* 1＝打开 WKT（开始按你设的周期滴答）。
  常见写法：`WKTCH = 0x80 | (高4位计数)`，示例里为了简单用了 `0x80` + 低位全在 `WKTCL`。

---

# 8) “看得见”和“更省电”的取舍怎么调？

三种常用策略：

1. **增大 WKT 周期**（比如从 `0xFF` 到更大值，或“多次唤醒后才翻转一次”）：

   * 闪烁变慢，**平均功耗更低**；
2. **缩短清醒停留（减少/移除 delay_ms）**：

   * 视觉上闪烁更短促（甚至看不清），但**更省电**；
3. **组合**：比如“唤醒马上翻转→立刻睡”，**纯靠 WKT 周期控制闪烁**。

> 小技巧：如果想要**1秒左右**的肉眼闪烁，但又想省电，
>
> * 用 `WKT≈100ms`，**计10次**再翻转 LED；
> * 这样每次醒来只清醒几百微秒，**其余 99% 时间都在睡**。

---

# 9) 常见坑（都是省电相关）

* **WKT没开**：忘记把 `WKTCH` 的最高位置 1 → 睡了就再也醒不来（表象：程序像“卡死”）。
* **唤醒间隔太短**：肉眼看不到任何闪烁，以为不工作；其实它在“快闪+快睡”。
* **进睡立刻又醒**：WKT 计数太小，或别的唤醒源在作祟（一般关闭其它唤醒源即可）。
* **IO被外设拖拽**：下载线、外接模块还占着 P3.0/P3.1，导致电平不对或耗电变高。
* **清醒阶段做太多事**：delay 太长、打印串口太多 → 功耗上不去；要省电就“短平快”。

---

# 10) 用一句话再总结

**省电套路**＝**设闹钟(WKT)** → **睡(PCON=0x02)** → **闹钟到点自动叫醒** → **干点事（翻灯/采样/上报）** → **再睡**。
想更省：**缩短清醒时间**、**拉长睡眠时间**；
想“看得见”：**保留一点可见停留**或**用多次唤醒合成慢闪**。



