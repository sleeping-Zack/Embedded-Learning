**一.单片机的 I/O 口是怎么控制外部设备（如 LED），实现开关的。**

---

## 1. I/O 口是什么

* 单片机有一排排“引脚”，我们叫 **I/O 口（输入/输出口）**。
* 每个 I/O 口都能通过软件（程序里的寄存器）控制成 **高电平(1)** 或 **低电平(0)**。
* 高电平 ≈ 接近 VCC（比如 5V），低电平 ≈ 0V（接地 GND）。

---

## 2. 控制原理

I/O 口就像一个“电子开关”：

* 输出 **高电平 (1)** → 等于在这根线上接上电源正极。
* 输出 **低电平 (0)** → 等于在这根线上接地。

然后我们把外部设备接在 **电源和 I/O 口之间**，电流是否流动就由 I/O 电平决定。

---

## 3. 例子：LED 控制

### 接法 1：高电平点亮（源电流方式,本实验不需要）

```
VCC  ─ LED ──> I/O 口
```

* I/O=0V → LED 两端是 5V–0V → 有电流，**LED亮**。
* I/O=5V → LED 两端电压=0 → **LED灭**。

### 接法 2：低电平点亮（灌电流方式，例如此实验）

```
I/O 口 ─ LED  ─ VCC
```

* I/O=0V → 电流从 VCC → LED → I/O → GND，**LED亮**。
* I/O=5V → 电流没法流动，**LED灭**。

👉 板子上的 LED 就是用“灌电流”方式：输出 0 → 亮，输出 1 → 灭。

---


## 5. 总结一句话

> **单片机 I/O 口 = 可编程的电子开关**
>
> * 输出 1 → 接电源
> * 输出 0 → 接地
>   通过选择 I/O 电平，就能控制外部设备“有无电流流过”，从而实现 **开关**
  
**二.搞清楚程序控制的代码，即代码如何影响单片机I/O**
---

## 1) 8051/STC15 的 I/O 是什么

* 每个端口有一个 **SFR（特殊功能寄存器）**：`P0、P1、P2、P3…`
* **往端口寄存器写入** → 立刻改变管脚的电气行为（“拉高/拉低等”）
* **从端口寄存器读取** → 读到的是“当前引脚上的电平”（受外部电路影响）



---

## 2) STC15（含 STC15F104W）的端口模式

STC15 系列给每个口都配了 **PxM1 / PxM0** 两个寄存器来设置每一位的模式（端口 x 的第 n 位由 `PxM1.n`、`PxM0.n` 决定）：

| `PxM1.n PxM0.n` | 模式                           | 电气特性与用法                                                                     |
| --------------- | ---------------------------- | --------------------------------------------------------------------------- |
| `00`            | **准双向（quasi-bidirectional）** | 默认；内部弱上拉。给该位**写 1** = 释放为输入/高阻+弱上拉；**写 0** = 强拉低（输出 0）。适合“**按键输入 + 简单输出**”。 |
| `01`            | **推挽输出（push-pull）**          | 能强拉高/强拉低，驱动能力最好（点 LED、驱动三极管首选）。读取也能读到脚上电平。                                  |
| `10`            | **仅输入（高阻）**                  | 纯输入，**没有内部上拉**，需要外部上/下拉。                                                    |
| `11`            | **开漏输出（open-drain）**         | 只能拉低，拉高要靠**外部上拉电阻**。适合 I²C、线与等。                                             |

> 结论：
>
> * 控 LED 这种“明确输出”的脚 ⇒ 设 **推挽输出**（`01`）。
> * 接拨码/按键这种“读电平”的脚 ⇒ 设 **准双向(00) + 给该位写 1 释放为输入**，或设 **仅输入(10) + 外部上拉/下拉**。

---

## 3) 你板子的典型初始化

你的板：

* **LED1 → P3.0**（拉低亮，灌电流）
* **LED2 → P3.1**（拉低亮，灌电流）
* **SW4 → P3.5**（拨到一边上拉为 1，另一边下拉为 0）

初始化把 LED 脚设成推挽输出，把开关脚设成输入（准双向并释放）：

```c
#include <reg52.h>

// STC15 端口模式寄存器（Keil 没定义时手动声明）
sfr P3M1 = 0xB1;
sfr P3M0 = 0xB2;

// 位别名（更直观）
sbit LED1 = P3^0;      // 0 亮，1 灭
sbit LED2 = P3^1;      // 0 亮，1 灭
sbit SW4I = P3^5;      // 读开关

void io_init(void){
    // P3.0、P3.1 => 推挽输出（01）
    P3M1 &= ~((1<<0) | (1<<1));   // 对应位 M1=0
    P3M0 |=  ((1<<0) | (1<<1));   // 对应位 M0=1

    // P3.5 => 准双向输入（00），并写1释放为输入（弱上拉）
    P3M1 &= ~(1<<5);    // M1=0
    P3M0 &= ~(1<<5);    // M0=0
    SW4I = 1;           // ★关键：写1→释放为输入(弱上拉)
}
```

> 如果你想让 P3.5 绝对高阻输入（自己接外部上拉/下拉），把 P3.5 设为 **仅输入(10)**：
>
> ```c
> P3M1 |=  (1<<5);
> P3M0 &= ~(1<<5);
> ```
>
> 这时 **必须**有外部上/下拉，否则会飘。

---

## 4) 程序如何“开关”外设（IO 写）

* **点亮 LED（拉低）**

  ```c
  LED1 = 0;   // 灌电流 → 亮
  LED2 = 1;   // 置高 → 灭
  ```
* **交替闪烁**（对称写法，减少不均）

  ```c
  LED1 = 0; LED2 = 1;  // LED1亮 LED2灭
  // delay...
  LED1 = 1; LED2 = 0;  // LED1灭 LED2亮
  // delay...
  ```

---

## 5) 程序如何“读取”开关（IO 读）

**规则（重要）**：

* 对 **准双向口**，**先写 1** 把该位释放为输入，再 `if(SW4I==0/1)` 读取。
* 读值要**防抖**（机械触点 5–20 ms 抖动）。

```c
bit sw4_read(void){
    SW4I = 1;                 // 释放输入（弱上拉）
    if(SW4I == 0){            // 低电平
        // 简单软件防抖
        unsigned char i;
        for(i=0; i<20; i++);  // ~几百微秒到几毫秒，或写成 delay_ms(10)
        return (SW4I == 0);
    }
    return 0;
}
```

---

## 6) 把“模式 + 读写”串起来（演示）

```c
void main(void){
    io_init();

    while(1){
        if(SW4I == 1){                 // SW4=高 → 模式A（交替闪烁）
            LED1 = 0; LED2 = 1;
            // delay_ms(500);
            LED1 = 1; LED2 = 0;
            // delay_ms(500);
        }else{                          // SW4=低 → 模式B（LED1常亮）
            LED1 = 0;
            LED2 = 1;
        }
    }
}
```

> 若你发现 SW4 总“没反应”，90% 是 **没把 P3.5 写 1 作为输入**、或之前用整口写 `P3=...` 把 P3.5 连带改坏了。上面全用位操作，规避这个坑。

---

## 7) 常见“为什么没反应”的根因清单

1. **没设端口模式** → 用默认准双向去强驱动 LED，能力不足或时序异常。
2. **没把输入位写 1 释放**（准双向特性）→ 读不到开关状态。
3. **整口写 P3** 把别的位误改（尤其是输入位）→ 看起来“失灵”。
4. **与复用功能冲突**（如 P3.0/P3.1 同时是串口）→ 下载/串口占用时表现异常。
5. **对拉**（外部上拉+程序强拉低或相反）→ 电压卡在 1～2V。
6. **防抖没有** → 判断忽明忽暗或抖动。
7. **没共地**（外接模块）→ 读写全异常。

---

## 8) 一句话总结

* **模式决定能力**：推挽=强驱动；准双向=通用；仅输入=高阻；开漏=拉低+外部上拉。
* **写值改变状态**：对输出脚写 0/1 就是“关/开”；对准双向输入脚先 **写 1 再读**。
* **程序即开关逻辑**：写寄存器=改电平=让电流“能/不能”走；读寄存器=感知外部电平=实现判断与控制。
