1.烧录程序时,提示已成功,但是实际结果并没有按我的代码执行:  
我在代码里设置的LED1亮1秒,LED2亮1秒,但是实际结果确实LED1和LED2亮2.6秒左右  
answer:  
之所以测到每次闪烁大约 2.6 秒，是因为 delay_ms 使用的双重空循环本身不精确，每次循环消耗的机器周期比预期多，再加上编译器优化和 11.0592MHz 时钟下的指令执行速度，导致延时远大于 1 毫秒，从而把本来设定的 1 秒延时拉长成约 2.6 秒，这正是纯软件延时容易出现误差的原因。
```c
#include <reg52.h>

void delay_ms(unsigned int ms){
    unsigned int i, j;
    for(i = ms; i > 0; i--)
        for(j = 1100; j > 0; j--);
}

void main(){
    while(1){
        // LED2亮
        P3 &= ~0x01;   // P3.0 = 0 
        P3 |=  0x02;   // P3.1 = 1 
        delay_ms(1000);   // 停留1秒

        // LED1亮
        P3 |=  0x01;   // P3.0 = 1 
        P3 &= ~0x02;   // P3.1 = 0 
        delay_ms(1000);    // 停留1秒
    }
}
```
2.当拔掉J+时,LED3仍常亮,且其后电压值与正常电压值接近:  
3.位寻址法与寄存器位运算区别比较  
answer:  
```c  //位寻址
P3^0 = 0;   // 清零 P3.0
P3^1 = 1;   // 置位 P3.1
```
特性：
Keil C 特有的语法扩展（不是标准 C）。直观、简单，一眼就能看出是操作某个位。只能用于 8051 单片机及兼容内核，移植性差。
```c  //寄存器
P3 &= ~0x01;   // 清零 P3.0
P3 |=  0x02;   // 置位 P3.1
P3 ^=  0x04;   // 翻转 P3.2
```
标准 C 语法，通用性强，几乎所有编译器都支持。不依赖编译器扩展，方便移植。
操作时是对整个寄存器做逻辑运算，然后赋值回去。  
4.推挽模式与开漏模式区别:  
推挽模式  
推挽输出是一种能够主动且强力地驱动高低电平的输出结构。它内部包含一对互补的开关管，像一个双刀开关。当输出高电平时，上管导通，直接将输出连接到电源电压；当输出低电平时，下管导通，直接将输出连接到地。这种一推一拉的方式使得输出电平非常明确，切换速度快，驱动能力强，非常适合直接驱动LED、进行高速数字通信（如SPI）等单一方向的强信号驱动场景。

开漏模式  
开漏输出是一种只能主动输出低电平的输出结构。它内部只有一个下拉开关管，无法主动输出高电平。当需要输出高电平时，开关管断开，依赖一个外部上拉电阻将电平拉高。这种特性带来了两大关键优势：一是可以实现“线与”功能，允许多个设备安全地共享一条总线（如I²C）；二是能轻松实现电平转换，只需改变上拉电阻所接的电源电压，即可让输出高电平适应不同电压的器件，因此非常适合总线通信和混合电压系统。
