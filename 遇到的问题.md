1.烧录程序时,提示已成功,但是实际结果并没有按我的代码执行:  
我在代码里设置的LED1亮1秒,LED2亮1秒,但是实际结果确实LED1和LED2亮2.6秒左右  
answer:  
之所以测到每次闪烁大约 2.6 秒，是因为 delay_ms 使用的双重空循环本身不精确，每次循环消耗的机器周期比预期多，再加上编译器优化和 11.0592MHz 时钟下的指令执行速度，导致延时远大于 1 毫秒，从而把本来设定的 1 秒延时拉长成约 2.6 秒，这正是纯软件延时容易出现误差的原因。
```c
#include <reg52.h>

void delay_ms(unsigned int ms){
    unsigned int i, j;
    for(i = ms; i > 0; i--)
        for(j = 1100; j > 0; j--);
}

void main(){
    while(1){
        // LED2亮
        P3 &= ~0x01;   // P3.0 = 0 
        P3 |=  0x02;   // P3.1 = 1 
        delay_ms(1000);   // 停留1秒

        // LED1亮
        P3 |=  0x01;   // P3.0 = 1 
        P3 &= ~0x02;   // P3.1 = 0 
        delay_ms(1000);    // 停留1秒
    }
}
```
2.当拔掉J+时,LED3仍常亮,且其后电压值与正常电压值接近:  
3.位寻址法与寄存器位运算区别比较  
answer:  
```c  //位寻址
P3^0 = 0;   // 清零 P3.0
P3^1 = 1;   // 置位 P3.1
```
特性：
Keil C 特有的语法扩展（不是标准 C）。直观、简单，一眼就能看出是操作某个位。只能用于 8051 单片机及兼容内核，移植性差。
```c  //寄存器
P3 &= ~0x01;   // 清零 P3.0
P3 |=  0x02;   // 置位 P3.1
P3 ^=  0x04;   // 翻转 P3.2
```
标准 C 语法，通用性强，几乎所有编译器都支持。不依赖编译器扩展，方便移植。
操作时是对整个寄存器做逻辑运算，然后赋值回去。
